/**
 * Created by chengfulin on 2015/4/13.
 */
var walkes = require('walkes'),
    Set = require('../set');

/**
 * Get KILL set
 * @param astNode
 * @returns Set of variable whose definition was defined in astNode
 * @constructor
 */
module.exports.KILL = function (astNode) {
    'use strict';
    var variables = new Set();
    /// KILL(n)
    /// 1. Variable redefined by assignment expression
    /// 2. Define object property by assignment expression
    /// 3. Update by UpdateExpression
    walkes(astNode, {
        Program: function () {},
        AssignmentExpression: function (node, recurse) {
            if (node.left.type === 'MemberExpression') {
                recurse(node.left.object);
            } else {
                recurse(node.left);
            }
            if (node.right.type === 'AssignmentExpression') {
                recurse(node.right);
            }
        },
        UpdateExpression: function (node, recurse) {
            recurse(node.argument);
        },
        BinaryExpression: function () {},
        FunctionDeclaration: function () {},
        FunctionExpression: function () {},
        VariableDeclaration: function () {},
        VariableDeclarator: function () {},
        SwitchCase: function (node, recurse) {
            node.consequent.forEach(recurse);
        },
        Identifier: function (node) {
            variables.add(node.name);
        }
    });
    return variables;
};

/**
 * Get GEN set
 * @param astNode
 * @returns Set of variable whose definition was not killed in astNode
 * @constructor
 */
module.exports.GEN = function (astNode) {
    'use strict';
    var variables = new Set();
    /// GEN(n)
    /// 1. Generated by variable declaration
    /// 2. Variable assignment
    /// 3. Update expression
    walkes(astNode, {
        Program: function () {},
        AssignmentExpression: function (node, recurse) {
            if (node.left.type === 'MemberExpression') {
                recurse(node.left.object);
            } else {
                recurse(node.left);
            }
            if (node.right.type === 'AssignmentExpression') {
                recurse(node.right);
            }
        },
        BinaryExpression: function () {},
        FunctionDeclaration: function () {},
        FunctionExpression: function () {},
        VariableDeclaration: function (node, recurse) {
            node.declarations.forEach(function (elem) {
                recurse(elem);
            });
        },
        VariableDeclarator: function (node, recurse) {
            recurse(node.id);
        },
        UpdateExpression: function (node, recurse) {
            recurse(node.argument);
        },
        SwitchCase: function (node, recurse) {
            node.consequent.forEach(recurse);
        },
        Identifier: function (node) {
            variables.add(node.name);
        }
    });
    return variables;
};

/**
 * Get last definitions of definition at a node
 * @param cfgNode a node of CFG which has added attribute 'cfgId'
 * @param def definition name
 * @returns Set of cfgIds where the last definitions are
 * @constructor
 */
module.exports.LastDEFs = function (cfgNode, def) {
    'use strict';
    var lastDefNodes = new Set();
    if (!!cfgNode && !Array.isArray(def) && typeof(def) === 'string') {
        (function recursive(node) {
            if (module.exports.GEN(node.astNode).values().indexOf(def) !== -1) {
                lastDefNodes.add(node.cfgId);
            } else {
                node.prev.forEach(recursive);
            }
        }(cfgNode));
    }
    return lastDefNodes;
};

/**
 * Get used variables at the node
 * @param astNode
 * @constructor
 * @returns Set of variable names used at this node
 */
module.exports.USE = function (astNode) {
    'use strict';
    var variables = new Set();
    walkes(astNode, {
        Program: function () {},
        AssignmentExpression: function (node, recurse) {
            if (node.right.type === 'AssignmentExpression') {
                /// Since it is a sequence of assignment
                if (node.right.left.type === 'Identifier') {
                    recurse(node.right.left);
                }
                recurse(node.right);
            } else if (node.right.type === 'Identifier') {
                /// simple assignment
                recurse(node.right);
            }
        },
        BinaryExpression: function (node, recurse) {
            /// Both operand are used
            recurse(node.left);
            recurse(node.right);
        },
        FunctionDeclaration: function () {},
        FunctionExpression: function () {},
        CallExpression: function (node, recurse) {
            /// When calling object method
            if (node.callee.type === 'MemberExpression') {
                recurse(node.callee.object);
            } else {
                /// otherwise, calling a normal function
                recurse(node.callee);
            }
            /// for the function arguments
            node.arguments.forEach(recurse);
        },
        VariableDeclaration: function (node, recurse) {
            node.declarations.forEach(function (elem) {
                if (elem.init.type === 'AssignmentExpression') {
                    /// e.g., var answer = var1 = var2;
                    recurse(elem.init.left);
                }
                recurse(elem.init);
            });
        },
        VariableDeclarator: function () {},
        UpdateExpression: function (node, recurse) {
            recurse(node.argument);
        },
        SwitchStatement: function (node, recurse) {
            /// add a use of switch test
            recurse(node.discriminant);
            /// get inside each case
            node.cases.forEach(recurse);
        },
        SwitchCase: function (node, recurse) {
            /// each statement inside the case
            node.consequent.forEach(recurse);
        },
        Identifier: function (node) {
            variables.add(node.name);
        }
    });
    return variables;
};